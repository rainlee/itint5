/*
1. 计算dx=x-x2,dy=y-y2。
2. 求出p,q的最大公约数g，如果dx或者dy不能被g整除，那么很显然无解。
3. 将p,q,dx,dy都除以g，现在p和q互质了。
4. 注意到马可以跳到点(0,2p)（先(p,q)跳一下，然后(p,-q)跳一下），重复这个过程，
   马可以跳到任意(0,2kp)的点，由于对称性，也可以跳到任意(2kp,0)的点。 
5.下面这一步很关键，由于p,q互质，那么存在x,y满足px+qy=1（扩展欧几里德定理）。
   这样，马可以跳到(0,2)和和(2,0)，由于对称性，马可以跳到任意坐标都为偶数点。
6. 有了上面的结论，其实只用考虑(0,0),(0,1),(1,0),(1,1)这4个点是否可达。
   (0,0)是可达的，(0,1)和(1,0)由于对称性只用考虑(0,1)。
7. 对于(1,1)，其实是永远可达的。
   如果q,p都为奇数，可以先跳到(1+p,1+q)的点（利用5中的结论，可以跳到都是偶数的点），然后(-p,-q)跳到(1,1)。
   如果p,q一奇一偶，可以先跳到(1+p+q,1+q+p)的点（利用5中的结论），然后(-p,-q),(-q,-p)两步跳到(1,1)。
8. 对于(0,1)，
   如果p,q一奇一偶，那么也是永远可达的（同7可证）。
   如果p,q都是奇数，那么是不可能跳到(0,1)的，因为两个奇数不管怎么加减交替运算都不可能变成一奇一偶。
所以最后的结论就是：第3步之后，如果p,q一奇一偶，那么可达。否则dx,dy同奇或同偶才可达。
*/
int gcd(int a, int b)
{
    return (0 == b) ? a : gcd(b, a%b);
}

bool canJump(int p, int q, int x, int y, int x2, int y2) {
    if(p == 0 && q == 0) 
        return (x==x2 && y==y2);
    
    int dx = x - x2;
    int dy = y - y2;
    
    int g = gcd(p, q);    
    if ((0 != dx%g) || (0 != dy%g))
        return false;
    
    if ((p + q) & 0x01)
        return true;
    else if (!((dx + dy) & 0x01))
        return true;
    else
        return false;
}